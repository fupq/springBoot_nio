jvm,是java虚拟机java virtual machine的简称；
1.类中被static修改的变量是存储在jvm的方法区（永久区）；
2.调优问题：web开发定义常量太多好不好？
	答复：不好，常量是存储在方法区（永久区），不会被java的内存回收机制回收，定义太多了，占用过多的内存，会引起内存溢出；
3.jvm的方法区（永久区）的变量是被所有线程共享的；要注意线程安全问题，使用synchronized锁或lock锁；
4.堆heap：创建的对象和使用new创建的数组等对象都存储在jvm的堆内存中；
5.栈：定义的基本局部变量，都存储在栈中。特点：程序运行完毕后清空；类的方法存储在栈里面；
	栈是每个线程私有，互不共享，不会产生线程安全问题。
6.本地方法栈：调用C语音使用.JNI是Java Native Interface的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C&C++）
7.PC寄存器：每个线程私有，线程安全；包含操作指针和计算变量的指令；
8.执行引擎：负责执行字节码文件；
9.垃圾回收机制：不定时地回收堆内存的空间资源；

################################# 堆heap[hiːp] #################################################33
1.堆内存存储使用new关键字创建的对象；
2.堆中包含两个区，新生代new generation和老年代tenured generation；
3.新生代区：垃圾回收机制没有经常来回收的区域；刚创建的对象先存储在新生代区；
4.新生代包含3个区，eden区，s0区，s1区；
5.s0区和s1区大小是相等的（目的：垃圾回收机制复制算法决定的）；对象创建后先放入eden区，若开始频繁使用，则转移到s0区或者s1区，若继续频繁使用则将变量晋升到老年区中；
6.老年代：如果对象频繁地使用，则将对象放入老年代中；
	6.1问题：垃圾回收机制需要经常到老年区回收垃圾吗？
	        答复：不需要，因为老年区存放的是经常频繁使用的对象；
	6.2问题：垃圾回收机制主要回收哪个区域？
	       答复：垃圾回收机制主要回收新生代区存储的对象；
	6.3问题：存储于老年代区的对象会回到新生代区中存储吗？
	       答复：不会，垃圾回收机制在老年代区也会回收，只是垃圾回收的频率低（次数相对新生代少）；
7.jvm调优：
	1.尽量减少垃圾回收的次数；因为垃圾回收时其它线程都会被卡死，经常进行垃圾回收会影响效率；
	2.新生代区垃圾回收次数比老年代区垃圾回收次数要多，尽量减少老年代区的垃圾回收次数；
	3.web系统中尽量减少常量（静态变量），否则占用的内容过多，引起内存溢出（内存不够用）；
8.在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。
9.引用变量：
	在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，
	在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，
	引用变量相当于为数组或者对象起的一个别名，或者代号。
10.java堆的结构：
	根据垃圾回收机制的不同，Java堆有可能拥有不同的结构，最为常见的就是将整个Java堆分为
	新生代和老年代。其中新生带存放新生的对象或者年龄不大的对象，老年代则存放老年对象。
	新生代分为den区、s0区、s1区，s0和s1也被称为from和to区域，他们是两块大小相等并且可以互相角色的空间。
	绝大多数情况下，对象首先分配在eden区，在新生代回收后，如果对象还存活，则进入s0或s1区，之后每经过一次
	新生代回收，如果对象存活则它的年龄就加1，对象达到一定的年龄后，则进入老年代。

################################################ 栈stack [stæk] #####################################
1.Java栈是一块线程私有的空间，一个栈，一般由三部分组成:局部变量表、操作数据栈和帧数据区
2.局部变量表：用于报错函数的参数及局部变量
3.操作数栈：主要保存计算过程的中间结果，同时作为计算过程中的变量临时的存储空间。
4.帧数据区:除了局部变量表和操作数据栈以外，栈还需要一些数据来支持常量池的解析，这里帧数据区保存着
	访问常量池的指针，方便程序访问常量池，另外当函数返回或出现异常时虚拟机必须有一个异常处理表，方便发送异常
	的时候找到异常的代码，因此异常处理表也是帧数据区的一部分。

################################################ 方法区 #####################################
Java方法区和堆一样，方法区是一块所有线程共享的内存区域，他保存系统的类信息。
比如类的字段、方法、常量池等。方法区的大小决定系统可以保存多少个类。如果系统
定义太多的类，导致方法区溢出。虚拟机同样会抛出内存溢出的错误。方法区可以理解
为永久区。


################################################ JVM参数调优 #####################################
1.什么是虚拟机参数配置？
	在虚拟机运行的过程中，如果可以跟踪系统的运行状态，那么对于问题的故障
	排查会有一定的帮助，为此，在虚拟机提供了一些跟踪系统状态的参数，使用
	给定的参数执行Java虚拟机，就可以在系统运行时打印相关日志，用于分析实际
	问题。我们进行虚拟机参数配置，其实就是围绕着堆、栈、方法区、进行配置。
	
2.GC:Garbage Collection	垃圾回收；garbage['gɑːbɪdʒ]垃圾，collection:回收
3.堆的参数配置
-XX:+PrintGC      每次触发GC的时候打印相关日志;print garbage collection
-XX:+UseSerialGC      串行回收 use serial(['sɪərɪəl]) garbage collection
-XX:+PrintGCDetails  更详细的GC日志
-Xms               堆初始值(堆初始值越小，垃圾回收此时越多，性能越低）
-Xmx               堆最大可用值 ;max：最大的
-Xmn               新生代堆最大可用值 ；max new
-XX:NewRatio	        老年代/新生代
-XX:SurvivorRatio     用来设置新生代中eden空间和from/to空间的比例. survivor [sə'vaɪvə]生还者  ratio['reɪʃɪəʊ]比例
含以-XX:SurvivorRatio=eden/from=den/to
总结:在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，
这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。

-XX:SurvivorRatio     用来设置新生代中eden空间和from/to空间的比例.

串行回收：GC线程单线程回收； serial(['sɪərɪəl])串行
并行回收：GC线程多线程回收 ；parallel  ['pærəlel]并行
-XX:ParallelGCThreads=8（并行回收线程数：cpu核数X2）
参数: -Xms200m -Xmx200m –Xmn50m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC

eg:-vmargs -Xms128M -Xmx512M -XX:PermSize=64M -XX:MaxPermSize=128M
-vmargs 说明后面是VM的参数，所以后面的其实都是JVM的参数了
-Xms128m JVM初始分配的堆内存
-Xmx512m JVM最大允许分配的堆内存，按需分配
-XX:PermSize=64M JVM初始分配的非堆内存
-XX:MaxPermSize=128M JVM最大允许分配的非堆内存，按需分配
################# JVM调优优化点 #########################
1.将初始的堆大小与最大堆大小相等，来减少GC垃圾回收次数；
	-Xms               堆初始值(堆初始值越小，垃圾回收此时越多，性能越低）
	-Xmx               堆最大可用值 ;max：最大的
2.设置新生代GC次数比老年代GC次数多，可设置新生代空间与老年代空间比例是1:3或1:4；-XX:NewRatio=老年代/新生代
	-Xmx               堆最大可用值 ;max：最大的
	-Xmn               新生代堆最大可用值 ；
eg:-Xms1000m -Xmx1000m -Xmn200m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC -XX:NewRatio=4	
############################################### 堆heap溢出  ############################################################
1.错误原因: java.lang.OutOfMemoryError: Java heap space
解决办法:设置堆内存大小 -Xms1m -Xmx70m -XX:+HeapDumpOnOutOfMemoryError
	将堆内存大小设置大一些

#################################### stack栈溢出 ###############################33333
1.栈溢出java.lang.StackOverflowError;
原因：方法中递归调用无限次，消耗了栈空间；不是循环调用方法；
解决方案：解决办法:设置线程最大调用深度
	-Xss5m 设置最大调用深度


##############################  复制算法  #############################################
优点：对象的存储空间连续，不会碎片化；
算法：引用标记算法计算对象a的标记值，当标记值大于15时，对象升级到S1当前可用区（假设当前S1可用，S0区未待清空区），当GC堆S1中的不可达对象回收时，是将可达对象都赋值到
		S0区（连续存放），然后将S1区全部清空；下次GC线程回收S0的不可达对象时，是将S0区可达对象全部赋值到S1区（连续存放），然后将S0区全部清空；
特点：S0或S1任一时刻都有一个是当前可用的，另一个是不可用的（存储待清空的区域）；



